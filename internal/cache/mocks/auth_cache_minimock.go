// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/solumD/auth/internal/cache.AuthCache -o auth_cache_minimock.go -n AuthCacheMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/solumD/auth/internal/model"
)

// AuthCacheMock implements mm_cache.AuthCache
type AuthCacheMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, user *model.User) (err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, user *model.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mAuthCacheMockCreateUser

	funcDeleteUser          func(ctx context.Context, userID int64) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, userID int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mAuthCacheMockDeleteUser

	funcGetUser          func(ctx context.Context, userID int64) (up1 *model.User, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, userID int64)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mAuthCacheMockGetUser
}

// NewAuthCacheMock returns a mock for mm_cache.AuthCache
func NewAuthCacheMock(t minimock.Tester) *AuthCacheMock {
	m := &AuthCacheMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mAuthCacheMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*AuthCacheMockCreateUserParams{}

	m.DeleteUserMock = mAuthCacheMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*AuthCacheMockDeleteUserParams{}

	m.GetUserMock = mAuthCacheMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*AuthCacheMockGetUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthCacheMockCreateUser struct {
	optional           bool
	mock               *AuthCacheMock
	defaultExpectation *AuthCacheMockCreateUserExpectation
	expectations       []*AuthCacheMockCreateUserExpectation

	callArgs []*AuthCacheMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthCacheMockCreateUserExpectation specifies expectation struct of the AuthCache.CreateUser
type AuthCacheMockCreateUserExpectation struct {
	mock               *AuthCacheMock
	params             *AuthCacheMockCreateUserParams
	paramPtrs          *AuthCacheMockCreateUserParamPtrs
	expectationOrigins AuthCacheMockCreateUserExpectationOrigins
	results            *AuthCacheMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthCacheMockCreateUserParams contains parameters of the AuthCache.CreateUser
type AuthCacheMockCreateUserParams struct {
	ctx  context.Context
	user *model.User
}

// AuthCacheMockCreateUserParamPtrs contains pointers to parameters of the AuthCache.CreateUser
type AuthCacheMockCreateUserParamPtrs struct {
	ctx  *context.Context
	user **model.User
}

// AuthCacheMockCreateUserResults contains results of the AuthCache.CreateUser
type AuthCacheMockCreateUserResults struct {
	err error
}

// AuthCacheMockCreateUserOrigins contains origins of expectations of the AuthCache.CreateUser
type AuthCacheMockCreateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mAuthCacheMockCreateUser) Optional() *mAuthCacheMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for AuthCache.CreateUser
func (mmCreateUser *mAuthCacheMockCreateUser) Expect(ctx context.Context, user *model.User) *mAuthCacheMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthCacheMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthCacheMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("AuthCacheMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &AuthCacheMockCreateUserParams{ctx, user}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthCache.CreateUser
func (mmCreateUser *mAuthCacheMockCreateUser) ExpectCtxParam1(ctx context.Context) *mAuthCacheMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthCacheMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthCacheMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("AuthCacheMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &AuthCacheMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectUserParam2 sets up expected param user for AuthCache.CreateUser
func (mmCreateUser *mAuthCacheMockCreateUser) ExpectUserParam2(user *model.User) *mAuthCacheMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthCacheMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthCacheMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("AuthCacheMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &AuthCacheMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user
	mmCreateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the AuthCache.CreateUser
func (mmCreateUser *mAuthCacheMockCreateUser) Inspect(f func(ctx context.Context, user *model.User)) *mAuthCacheMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for AuthCacheMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by AuthCache.CreateUser
func (mmCreateUser *mAuthCacheMockCreateUser) Return(err error) *AuthCacheMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthCacheMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthCacheMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &AuthCacheMockCreateUserResults{err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the AuthCache.CreateUser method
func (mmCreateUser *mAuthCacheMockCreateUser) Set(f func(ctx context.Context, user *model.User) (err error)) *AuthCacheMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the AuthCache.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the AuthCache.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the AuthCache.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mAuthCacheMockCreateUser) When(ctx context.Context, user *model.User) *AuthCacheMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthCacheMock.CreateUser mock is already set by Set")
	}

	expectation := &AuthCacheMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &AuthCacheMockCreateUserParams{ctx, user},
		expectationOrigins: AuthCacheMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up AuthCache.CreateUser return parameters for the expectation previously defined by the When method
func (e *AuthCacheMockCreateUserExpectation) Then(err error) *AuthCacheMock {
	e.results = &AuthCacheMockCreateUserResults{err}
	return e.mock
}

// Times sets number of times AuthCache.CreateUser should be invoked
func (mmCreateUser *mAuthCacheMockCreateUser) Times(n uint64) *mAuthCacheMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of AuthCacheMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mAuthCacheMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_cache.AuthCache
func (mmCreateUser *AuthCacheMock) CreateUser(ctx context.Context, user *model.User) (err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, user)
	}

	mm_params := AuthCacheMockCreateUserParams{ctx, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := AuthCacheMockCreateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("AuthCacheMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("AuthCacheMock.CreateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("AuthCacheMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the AuthCacheMock.CreateUser")
		}
		return (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to AuthCacheMock.CreateUser. %v %v", ctx, user)
	return
}

// CreateUserAfterCounter returns a count of finished AuthCacheMock.CreateUser invocations
func (mmCreateUser *AuthCacheMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of AuthCacheMock.CreateUser invocations
func (mmCreateUser *AuthCacheMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to AuthCacheMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mAuthCacheMockCreateUser) Calls() []*AuthCacheMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*AuthCacheMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *AuthCacheMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *AuthCacheMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthCacheMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthCacheMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthCacheMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to AuthCacheMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthCacheMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mAuthCacheMockDeleteUser struct {
	optional           bool
	mock               *AuthCacheMock
	defaultExpectation *AuthCacheMockDeleteUserExpectation
	expectations       []*AuthCacheMockDeleteUserExpectation

	callArgs []*AuthCacheMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthCacheMockDeleteUserExpectation specifies expectation struct of the AuthCache.DeleteUser
type AuthCacheMockDeleteUserExpectation struct {
	mock               *AuthCacheMock
	params             *AuthCacheMockDeleteUserParams
	paramPtrs          *AuthCacheMockDeleteUserParamPtrs
	expectationOrigins AuthCacheMockDeleteUserExpectationOrigins
	results            *AuthCacheMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthCacheMockDeleteUserParams contains parameters of the AuthCache.DeleteUser
type AuthCacheMockDeleteUserParams struct {
	ctx    context.Context
	userID int64
}

// AuthCacheMockDeleteUserParamPtrs contains pointers to parameters of the AuthCache.DeleteUser
type AuthCacheMockDeleteUserParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// AuthCacheMockDeleteUserResults contains results of the AuthCache.DeleteUser
type AuthCacheMockDeleteUserResults struct {
	err error
}

// AuthCacheMockDeleteUserOrigins contains origins of expectations of the AuthCache.DeleteUser
type AuthCacheMockDeleteUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mAuthCacheMockDeleteUser) Optional() *mAuthCacheMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for AuthCache.DeleteUser
func (mmDeleteUser *mAuthCacheMockDeleteUser) Expect(ctx context.Context, userID int64) *mAuthCacheMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthCacheMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &AuthCacheMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("AuthCacheMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &AuthCacheMockDeleteUserParams{ctx, userID}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthCache.DeleteUser
func (mmDeleteUser *mAuthCacheMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mAuthCacheMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthCacheMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &AuthCacheMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("AuthCacheMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &AuthCacheMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectUserIDParam2 sets up expected param userID for AuthCache.DeleteUser
func (mmDeleteUser *mAuthCacheMockDeleteUser) ExpectUserIDParam2(userID int64) *mAuthCacheMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthCacheMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &AuthCacheMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("AuthCacheMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &AuthCacheMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the AuthCache.DeleteUser
func (mmDeleteUser *mAuthCacheMockDeleteUser) Inspect(f func(ctx context.Context, userID int64)) *mAuthCacheMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for AuthCacheMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by AuthCache.DeleteUser
func (mmDeleteUser *mAuthCacheMockDeleteUser) Return(err error) *AuthCacheMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthCacheMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &AuthCacheMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &AuthCacheMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the AuthCache.DeleteUser method
func (mmDeleteUser *mAuthCacheMockDeleteUser) Set(f func(ctx context.Context, userID int64) (err error)) *AuthCacheMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the AuthCache.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the AuthCache.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the AuthCache.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mAuthCacheMockDeleteUser) When(ctx context.Context, userID int64) *AuthCacheMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthCacheMock.DeleteUser mock is already set by Set")
	}

	expectation := &AuthCacheMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &AuthCacheMockDeleteUserParams{ctx, userID},
		expectationOrigins: AuthCacheMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up AuthCache.DeleteUser return parameters for the expectation previously defined by the When method
func (e *AuthCacheMockDeleteUserExpectation) Then(err error) *AuthCacheMock {
	e.results = &AuthCacheMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times AuthCache.DeleteUser should be invoked
func (mmDeleteUser *mAuthCacheMockDeleteUser) Times(n uint64) *mAuthCacheMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of AuthCacheMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mAuthCacheMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_cache.AuthCache
func (mmDeleteUser *AuthCacheMock) DeleteUser(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, userID)
	}

	mm_params := AuthCacheMockDeleteUserParams{ctx, userID}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := AuthCacheMockDeleteUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("AuthCacheMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteUser.t.Errorf("AuthCacheMock.DeleteUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("AuthCacheMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the AuthCacheMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, userID)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to AuthCacheMock.DeleteUser. %v %v", ctx, userID)
	return
}

// DeleteUserAfterCounter returns a count of finished AuthCacheMock.DeleteUser invocations
func (mmDeleteUser *AuthCacheMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of AuthCacheMock.DeleteUser invocations
func (mmDeleteUser *AuthCacheMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to AuthCacheMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mAuthCacheMockDeleteUser) Calls() []*AuthCacheMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*AuthCacheMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *AuthCacheMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *AuthCacheMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthCacheMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthCacheMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthCacheMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to AuthCacheMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthCacheMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mAuthCacheMockGetUser struct {
	optional           bool
	mock               *AuthCacheMock
	defaultExpectation *AuthCacheMockGetUserExpectation
	expectations       []*AuthCacheMockGetUserExpectation

	callArgs []*AuthCacheMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthCacheMockGetUserExpectation specifies expectation struct of the AuthCache.GetUser
type AuthCacheMockGetUserExpectation struct {
	mock               *AuthCacheMock
	params             *AuthCacheMockGetUserParams
	paramPtrs          *AuthCacheMockGetUserParamPtrs
	expectationOrigins AuthCacheMockGetUserExpectationOrigins
	results            *AuthCacheMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthCacheMockGetUserParams contains parameters of the AuthCache.GetUser
type AuthCacheMockGetUserParams struct {
	ctx    context.Context
	userID int64
}

// AuthCacheMockGetUserParamPtrs contains pointers to parameters of the AuthCache.GetUser
type AuthCacheMockGetUserParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// AuthCacheMockGetUserResults contains results of the AuthCache.GetUser
type AuthCacheMockGetUserResults struct {
	up1 *model.User
	err error
}

// AuthCacheMockGetUserOrigins contains origins of expectations of the AuthCache.GetUser
type AuthCacheMockGetUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mAuthCacheMockGetUser) Optional() *mAuthCacheMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for AuthCache.GetUser
func (mmGetUser *mAuthCacheMockGetUser) Expect(ctx context.Context, userID int64) *mAuthCacheMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("AuthCacheMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &AuthCacheMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("AuthCacheMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &AuthCacheMockGetUserParams{ctx, userID}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthCache.GetUser
func (mmGetUser *mAuthCacheMockGetUser) ExpectCtxParam1(ctx context.Context) *mAuthCacheMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("AuthCacheMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &AuthCacheMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("AuthCacheMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &AuthCacheMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectUserIDParam2 sets up expected param userID for AuthCache.GetUser
func (mmGetUser *mAuthCacheMockGetUser) ExpectUserIDParam2(userID int64) *mAuthCacheMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("AuthCacheMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &AuthCacheMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("AuthCacheMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &AuthCacheMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.userID = &userID
	mmGetUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the AuthCache.GetUser
func (mmGetUser *mAuthCacheMockGetUser) Inspect(f func(ctx context.Context, userID int64)) *mAuthCacheMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for AuthCacheMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by AuthCache.GetUser
func (mmGetUser *mAuthCacheMockGetUser) Return(up1 *model.User, err error) *AuthCacheMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("AuthCacheMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &AuthCacheMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &AuthCacheMockGetUserResults{up1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the AuthCache.GetUser method
func (mmGetUser *mAuthCacheMockGetUser) Set(f func(ctx context.Context, userID int64) (up1 *model.User, err error)) *AuthCacheMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the AuthCache.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the AuthCache.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the AuthCache.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mAuthCacheMockGetUser) When(ctx context.Context, userID int64) *AuthCacheMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("AuthCacheMock.GetUser mock is already set by Set")
	}

	expectation := &AuthCacheMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &AuthCacheMockGetUserParams{ctx, userID},
		expectationOrigins: AuthCacheMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up AuthCache.GetUser return parameters for the expectation previously defined by the When method
func (e *AuthCacheMockGetUserExpectation) Then(up1 *model.User, err error) *AuthCacheMock {
	e.results = &AuthCacheMockGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times AuthCache.GetUser should be invoked
func (mmGetUser *mAuthCacheMockGetUser) Times(n uint64) *mAuthCacheMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of AuthCacheMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mAuthCacheMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_cache.AuthCache
func (mmGetUser *AuthCacheMock) GetUser(ctx context.Context, userID int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, userID)
	}

	mm_params := AuthCacheMockGetUserParams{ctx, userID}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := AuthCacheMockGetUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("AuthCacheMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUser.t.Errorf("AuthCacheMock.GetUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("AuthCacheMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the AuthCacheMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, userID)
	}
	mmGetUser.t.Fatalf("Unexpected call to AuthCacheMock.GetUser. %v %v", ctx, userID)
	return
}

// GetUserAfterCounter returns a count of finished AuthCacheMock.GetUser invocations
func (mmGetUser *AuthCacheMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of AuthCacheMock.GetUser invocations
func (mmGetUser *AuthCacheMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to AuthCacheMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mAuthCacheMockGetUser) Calls() []*AuthCacheMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*AuthCacheMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *AuthCacheMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *AuthCacheMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthCacheMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthCacheMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthCacheMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to AuthCacheMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthCacheMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthCacheMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthCacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthCacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetUserDone()
}
